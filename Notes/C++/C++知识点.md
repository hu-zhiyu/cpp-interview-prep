## C++知识点复习
### 第2章 类和对象初步
#### private、public和protected访问范围说明符的区别
private：一个类的private成员，不论是成员变量还是成员函数，都只能在该类的成员函数内部才能被访问。
public：一个类的公有成员在任何地方都可以被访问。
protected：介于private和public两者之间。能访问私有成员的地方都能访问保护成员。基类的保护成员可以在派生类的成员函数中被访问。

### 第3章 类和对象进阶
#### 全局变量和局部变量在初始化时的区别
全局变量在程序装入内存时就分配好了存储空间（静态存储区），程序运行期间其地址不变。对于程序员没有初始化的全局变量，程序启动时自动将其全部初始化为0。
局部变量定义在函数内部，其存储空间是动态分配在栈中的。函数被调用时，栈会分配一部分空间存放该函数中的局部变量（包括参数），这片新分配的存储空间原来的内容是什么，局部变量的初始内容就是什么。
#### 构造函数为对象分配内存空间吗？
构造函数执行时，对象的内存空间已经分配好了，构造函数的作用是初始化这片空间。
默认构造函数（即无参构造函数）不一定存在，但是复制构造函数（即拷贝构造函数）一定存在。
#### 复制构造函数被调用的三种情况
当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用（注意：赋值语句不会引发复制构造函数的调用）
如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。
如果函数的返回值是类 A 的对象，则函数返回时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。
#### 函数的形参值等于函数调用时对应的实参，这句话为什么不对？
如果形参是一个对象，那么形参的值是否等于实参，取决于该对象所属的类的复制构造函数是如何实现的。
#### 类型转换构造函数
除复制构造函数外，只有一个参数的构造函数一般都可以称作类型转换构造函数，因为这样的构造函数能起到类型自动转换的作用。
#### 析构函数
#### 静态成员变量和静态成员函数
普通成员变量每个对象有各自的一份，而静态成员变量只有一份，被所有同类对象共享。
普通成员函数一定是作用在某个对象上的，而静态成员函数并不具体作用在某个对象上。
访问静态成员时，可以通过“类名 :: 成员名”的方式访问，不需要指明被访问的成员属于哪个对象或者作用于哪个对象。
使用 sizeof 计算对象所占用的存储空间时，不会将静态成员变量计算在内。
静态成员变量本质上是一个全局变量。一个类，哪怕一个对象都不存在，其静态成员变量也是存在的。设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。
必须在定义类的文件中对静态成员变量进行一次声明或初始化，否则编译能通过，链接不能通过。（思考为什么？）
静态成员函数也不具体作用于某个对象，所以静态成员函数内部不能访问非静态成员变量，也不能调用非静态成员函数。
#### 常量对象和常量成员函数
不能通过常量对象调用普通成员函数，因为普通成员函数在执行过程中有可能修改对象的值。但是可以通过常量对象调用常量成员函数。所谓常量成员函数，就是在定义时加了const 关键字的成员函数（声明时也要加）。
常量对象上可以执行常量成员函数，是因为常量成员函数确保不会修改任何非静态成员变量的值，常量成员函数内部也不允许调用同类的其他非常量成员函数（静态成员函数除外）。
两个成员函数的名字和参数表相同，但一个是const的，另一个不是，则它们算重载。
基本上，如果一个成员函数中没有调用非常量成员函数，也没有修改成员变量的值，那么将其写成常量成员函数是好的习惯。
#### 常量成员函数内为什么可以修改静态成员变量的值？
#### 成员对象和封闭类
一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类。
封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类自己的构造函数。成员对象构造函数的执行次序和成员对象在类定义中的次序一致，与它们在构造函数初始化列表中出现的次序无关。当封闭类对象消亡时，先执行封闭类的析构函数，然后再执行成员对象的析构函数（即先构造的后析构）。
封闭类的对象，如果是用默认复制构造函数初始化的，那么它包含的成员对象也会用复制构造函数初始化。
#### 类的const成员变量和引用成员变量必须在构造函数的初始化列表中进行初始化。
#### 友元（友元函数和友元类）
在一个类的友元函数内部可以访问该类对象的私有成员（注意：不能把其他类的私有成员函数声明为友元）
如果类 A 将 类 B 声明为友元，那么类 B 的所有成员函数就都可以访问类 A 对象的私有成员（注意：友元关系在类之间不能传递）
#### this 指针
C++规定，在非静态成员函数内部可以直接使用 this 关键字，this 就代表指向该函数所作用的对象的指针（注意：在静态成员函数内部不能使用 this 指针
#### 在C++中，“类名 (构造函数实参表)”这种写法表示生成一个临时对象。该对象没有名字，生存期就到包含它的语句执行完为止。


### 第4章 运算符重载
#### 运算符重载为全局函数时，参数的个数等于运算符的目数（即操作数的个数）；运算符重载为成员函数时，参数的个数等于运算符的目数减一。
#### 以下运算符不能被重载：. / .* / :: / ?: / sizeof
#### 重载运算符 ( ) / [ ] / -> 或者赋值运算符 = 以及类型强制转换运算符时，只能将它们重载为成员函数，不能重载为全局函数
#### return this 与 return *this 的区别
return *this 返回的是当前对象的克隆或者本身（若返回类型为 A，则是克隆，若返回类型为A &，则是本身）；return this 返回的是当前对象的地址（即指向当前对象的指针）
#### 浅拷贝与深拷贝
浅拷贝：逐个字节进行拷贝
深拷贝：将一个对象中指针成员变量指向的内容复制到另一个对象中指针成员变量指向的地方
#### 重载强制类型转换运算符时，不需要指定返回值类型，因为返回值类型是确定的，就是运算符本身代表的类型
#### 编译器处理自增/自减运算符时，如何区分前置还是后置？
C++规定，在重载“++”或“- -”时，允许写一个增加了无用 int 类型形参的版本，编译器处理前置表达式时，调用参数个数正常的重载函数；处理后置表达式时，调用多出一个参数的重载函数。
#### 前置和后置自增操作符的区别
后置++的执行效率比前置的低。因为后置方式的重载函数中要多生成一个局部对象，而对象的生成会引发构造函数的调用，需要一定开销。
前置运算符的返回值类型为该类对象的引用，而后置运算符的返回值类型就是该类的一个临时对象，这是因为运算符重载最好保持原运算符的用法。前置++的返回值本来就是操作数的引用，而后置++返回值则是操作数值修改前的复制品。
#### 为什么 (++a) = 2; 合法，但是 (a++) = 2; 非法？
++a 的返回值是引用，引用可以作为左值；a++的返回值是临时对象，不能作为左值。

### 第5章 继承与派生
#### 基类与派生类的概念
#### 派生类的成员函数不能访问基类的私有成员。派生类对象占用的存储空间大小，等于基类对象占用的存储空间大小加上派生类对象自身成员变量占用的存储空间大小。派生类对象中包含基类对象，而且基类对象的存储位置位于派生类对象新增的成员变量之前。
#### 派生类的成员覆盖基类的同名成员。如果要访问基类的同名成员，则需要在成员名前面加“基类名 :: ”。
#### 复合关系与继承关系
#### 基类的保护成员可以在派生类的成员函数中被访问（注意：派生类的成员函数只能访问所作用的那个对象，即this指针指向的对象的基类保护成员，不能访问其他基类对象的基类保护成员）
#### 在执行一个派生类的构造函数之前，总是先执行基类的构造函数。派生类对象消亡时，先执行派生类的析构函数，在执行基类的析构函数。如果一个派生类对象是用默认复制构造函数初始化的，那么它内部包含的基类对象也要用基类的复制构造函数初始化。（注意：多层次的派生，构造时先从最顶层的基类逐层往下执行构造函数，析构时则反之）
#### 包含成员对象的派生类对象生成时，构造函数的调用顺序
先从上至下执行所有基类的构造函数，再按照成员对象的定义顺序执行各个成员对象的构造函数，最后执行自身的构造函数；析构时则反之。
#### 公有派生的复制兼容规则
派生类的对象可以赋值给基类对象
派生类对象可以用来初始化基类引用
派生类对象的地址可以赋值给基类指针，也就是说，派生类的指针可以赋值给基类的指针（注意：即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有而派生类中有的成员）
#### 将基类指针或引用强制转换为派生类指针或引用，其安全性如何保证？
dynamic_cast



### 第6章 多态与虚函数
#### 多态和多态类的概念
多态的机制：派生类对象的地址可以赋值给基类指针。对于通过基类指针调用基类和派生类中都有的同名、同参数表的虚函数的语句，编译时并不确定要执行的是基类还是派生类的虚函数；而当程序运行到该语句时，如果基类指针指向的是一个基类对象，则基类的虚函数被调用，如果基类指针指向的是一个派生类对象，则派生类的虚函数被调用
包含虚函数的类就称为多态类。
#### 基于对象与面向对象的区别
区别在于是否支持多态。
#### 虚函数的概念
所谓虚函数，就是声明时前面加了virtual关键字的成员函数（注意：virtual关键字只在类定义中的成员函数声明处使用，不能在类外部写成员函数体时使用。静态成员函数不能是虚函数。）
#### 动态联编与静态联编的区别
多态的语句调用哪个类的成员函数是在运行时才确定的，编译时不能确定，因此多态的函数语句调用被称为是“动态联编”的，而普通的函数调用语句是“静态联编”的。
#### 通过基类引用 / 基类指针实现多态
#### 多态的作用
使用多态能够增强程序的可扩充性，即程序需要修改或增加功能时，只需改动或增加较少的代码。此外，使用多态能起到精简代码的作用。
#### 多态的实现原理
每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着该虚函数表的指针。虚函数表是编译器生成的，程序运行时被载入内存。一个类的虚函数表中列出了该类的全部虚函数地址。
多态的函数调用语句被编译成根据基类指针所指向的（或基类引用所引用的）对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的一系列指令。
多态机制能够提高程序的开发效率，但是也增加了程序运行时的开销。虚函数表、各个对象中包含的4个字节（或更多）的虚函数表的地址都是空间上的额外开销；而查虚函数表的过程则是时间上的额外开销。
#### 用基类指针数组存放指向各种派生类对象的指针，然后遍历该数组，就能对各个派生类对象做各种操作，这是很常用的做法。
#### 在成员函数、构造函数和析构函数中调用虚函数
在成员函数（静态成员函数、构造函数和析构函数除外）中调用其他虚成员函数的语句是多态的。
在构造函数和析构函数中调用虚函数不是多态，因为编译时即可确定调用的是哪个函数。如果本类有该函数，调用的就是本类的函数；如果本类没有，调用的就是直接基类的函数；如果直接基类没有，调用的就是间接基类的函数，以此类推。
#### 区分多态和非多态的情况
C++规定，只要基类中的某个函数被声明为虚函数，则派生类中的同名、同参数表的成员函数即使前面不写virtual关键字，也自动成为虚函数。
#### 虚析构函数
C++规定，需要将基类的析构函数声明为虚函数，即虚析构函数。
只要基类的析构函数是虚函数，那么派生类的析构函数无论是否用virtual关键字声明，都自动成为虚析构函数。
一般来说，一个类如果定义了虚函数，则最好将析构函数也定义为虚函数。（思考为什么）
析构函数可以是虚函数，但是构造函数不能是虚函数。
#### 纯虚函数和抽象类的概念
纯虚函数就是没有函数体的虚函数。包含纯虚函数的类就叫抽象类。
纯虚函数的写法就是在函数声明后面加“ =0 ”，不写函数体。纯虚函数实际上是不存在的，引入纯虚函数是为了便于实现多态。
之所以把包含纯虚函数的类称为“抽象类”，是因为这样的类不能生成独立的对象。抽象类可以作为基类，用来派生新的类。可以定义抽象类的指针或引用，并让它们指向或引用抽象类的派生类的对象，这就为多态的实现创造了条件。独立的抽象类的对象不存在，但是被包含在派生类对象中的抽象类的对象是可以存在的。
如果一个类从抽象类派生而来，那么当且仅当它对基类中的所有纯虚函数都进行覆盖并都写出函数体（空的函数体“{ }”也可以），它才能成为非抽象类。

### 第9章 泛型程序设计与模版
#### 什么是泛型程序设计？
泛型程序设计（generic programming）是一种算法在实现时不指定具体要操作的数据的类型的程序设计方法，也可以说，泛型程序设计就是大量编写模板、使用模板的程序设计。
#### 函数模版的写法与用法。
函数模板的写法:
```c
template <class/typename 类型参数1，class/typename 类型参数2，…>
返回值类型 模板名（形参表）
{
	函数体
}
```
编译器由模板自动生成函数时，会用具体的类型名对模板中所有的类型参数进行替换，其他部分则原封不动地保留。编译器在编译到调用函数模板的语句时，会根据实参的类型判断该如何替换模板中的类型参数。模板调用语句也可以明确指明要把类型参数实例化为哪种类型。
编译器由模板自动生成函数的过程叫模板的实例化。由模板实例化而得到的函数称为模板函数。
函数模板可以重载，只要它们的形参表不同即可。
#### 成员函数后加const关键字的作用是什么？
成员函数后加const，表明这个函数不会对这个类对象的数据成员做任何改变（只读不写）。
#### 函数或函数模板调用语句的匹配顺序
C++编译器遵循以下先后顺序：
先找参数完全匹配的普通函数
再找参数完全匹配的模板函数
再找参数经过自动转换后能够匹配的普通函数
如果上面的都找不到，则报错
#### 类模版的原理与写法
类模板的写法:
```c
template <class/typename 类型参数1，class/typename 类型参数2，…>
class 类模板名
{
	成员函数和成员变量
}
```
编译器由类模板生成类的过程叫类模板的实例化，由类模板实例化得到的类叫模板类。同一个类模板的两个模板类是不兼容的。

### 第10章 标准模版库STL
#### STL中的几个基本概念（容器、迭代器、算法）
#### 容器的分类：顺序容器、关联容器、容器适配器
#### 容器中常见的成员函数
#### 迭代器分类（正向迭代器、常量正向迭代器、反向迭代器、常量反向迭代器）
#### 容器适配器 stack、queue 和 priority_queue 没有迭代器
#### 总结不同容器的迭代器的功能
#### 什么情况下迭代器会失效？
对于序列式容器，比如vector，删除当前的iterator会使后面所有元素的iterator都失效 (使用erase函数删除会返回被删除元素的下一个元素的迭代器) 
对于链表型数据结构，比如list，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器
对于关联容器式(如map, set, multimap, multiset)，删除当前的iterator，仅仅会使当前的iterator失效
任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效
#### STL 中“大”、“小”和“相等”的概念
#### 三种顺序容器的区别、优劣比较
vector 和 deque 都是动态可变长数组。在 vector 容器的后部增删元素有很好的性能，在vector的开头或中间插入元素的性能很差。deque 则是在两端增删元素都具有很好的性能，但是在中间插入元素的性能很差。
list 是双向链表，在两端和中间增删元素都有很好的性能。
#### 函数对象的概念
#### STL 中两种sort算法的区别
#### set 与 multiset (map与multimap) 的区别
#### map 和 hash_map的区别

### 其他
#### 编译 (compile) 和构建 (build) 的区别，有哪些常用的编译和构建工具？
#### include时，使用双引号和尖括号有什么区别？
include “”先在当前目录下查找，如果找不到，再到系统目录下查找；include <>直接在系统目录下查找。
#### 头文件开头#pragma once有什么作用？
#### visual studio中debug和release两种调试模式有什么区别？
#### 自增操作 i++ 和 ++i 的区别，编译器如何区分前置和后置自增运算？
#### 将常引用作为形参的作用是什么？
把传入的参数的类型声明为引用，可以避免从形参到实参的过程中复制构造函数的调用，减少一定的开销。同时，声明为常量引用（const）可以避免改变传入的实例的状态。
#### 内联函数的概念。什么情况下应该使用内联函数而非普通函数？
C++中，可以在定义函数时，在返回值类型前面加上 inline 关键字 (称内联函数) 。当编译器处理内联函数的语句时，不会将该语句编译为函数调用的指令，而是直接将整个函数体的代码插入调用语句处，这样就省去了函数调用的开销。
内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。
定义在类内部的函数都是隐式的内联函数。
#### 封闭类
#### 内存泄漏是怎么回事？遇到过吗？如何排查？
#### 左值和右值的区别？
#### 哈希表 (无序容器) 如何实现查找元素的时间复杂度O(1) ?
#### C++11有哪些新特性？
#### 深拷贝与浅拷贝
#### 左值引用与右值引用
#### static_cast / reinterpret_cast / const_cast / dynamic_cast 分别用于哪些场合？ 
#### NULL 和 nullptr 有什么区别？
#### 赋值运算符函数返回引用有什么好处？返回引用可允许连续赋值
#### struct 和 class 有什么区别？
如果没有标明成员函数或者成员变量的访问权限级别，那么在
C++中，struct默认的是public，class默认的是private
C# 中，struct和class默认的都是private，区别在于struct定义的是值类型，值类型的实例在栈上分配内存，而class定义的是引用类型，引用类型的实例在堆上分配内存。
#### 堆和栈这两种内存管理方式有什么区别？什么时候会用到堆，什么时候用到栈？
从管理方式、空间大小、生长方向、分配方式、分配效率、存放内容等方面比较
#### struct在C和C++中有什么区别
在面向C的过程中，struct不能包含任何函数。否则编译器会报错；在C++中，struct得到了很大的扩充，可以包括成员函数，可以实现继承和多态。
#### 变量存储总结
局部变量：存储在栈中
全局变量、静态变量、字符串常量：静态存储区
动态申请的内存区：存储在堆中
#### length 和 sizeof 的区别，sizeof 的机制
#### using namespace std; 这句话的作用
#### new 和 malloc有什么区别？
#### 参数传引用与传值的区别
传值：形参的改变不会影响实参
传引用：形参和实参是一回事
#### 常引用与普通引用的区别
不能通过常引用去修改其引用的内容。注意，不是常引用所引用的内容不能被修改，只是不能通过常引用去修改。
#### 指针常量与常量指针（C++ Primer中分别称为指向常量的指针和常量指针）
常量指针：
定义：具有只能够读取内存中数据，却不能够修改内存中数据的属性的指针
声明：```c const int * p; int const * p; ```
指针常量：
指针所指向的位置不能改变，即指针本身是一个常量，但是指针所指向的内容可以改变
声明：```c int * const p = &a; ```
注：指针常量必须在声明的同时对其初始化，不允许先声明一个指针常量随后再对其赋值，这和声明一般的常量是一样的。

#### 指针与引用的区别（C++ Primer 47页）
指针和引用都属于复合类型，都实现了对其他对象的间接访问。其不同点在于：
引用不是一个对象，它只是为一个已经存在的对象所起的另外一个名字，也不能定义引用的引用。而指针本身就是一个对象，允许对指针拷贝和赋值，而且在指针的生命周期内它可以先后指向几个不同的对象。
定义引用时，必须对引用进行初始化，把引用和它的初始值绑定在一起。而指针无需在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
#### 虚函数、多继承、虚基类和RTTI所需的主要代价

#### C++中，new operator和operator new有什么区别？
#### 链表创建函数中，形参用一级指针和二级指针的区别。
#### 函数可以返回数组吗？为什么？如果要返回数组可以怎么做？
#### 以下两种声明: int *p1[10]; 和 int (*p2)[10]; 中p1和p2 各表示什么含义？
#### 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，即基类指针不能调用子类自己定义的成员函数。
#### 顶层const与底层const
顶层const（top-level const）表示对象本身是个常量，底层const（low-level const）表示指针所指向/引用所绑定的对象是一个常量。
#### 迭代器失效总结
赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为array和string的情况除外）。
向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。
删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。
如果resize缩小容器，则指向被删除元素的迭代器、引用和指针都会失效。对vector、string或deque进行resize可能导致迭代器、引用和指针失效。
#### 为什么forward_list不支持push_back / pop_back操作？
因为forward_list是单向链表，只支持从链表的头部插入元素，因此只支持push_front而不支持push_back操作。


