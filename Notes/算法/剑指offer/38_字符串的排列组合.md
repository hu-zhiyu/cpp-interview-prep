## 问题描述：输入一个字符串，打印出该字符串中字符的所有排列。例如，输入字符串abc，则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。
### 递归解法
```c
class Solution {
public:
    vector<string> Permutation(string str) {
        vector<string> result;
        int begin = 0;
        if(str.size()==0){
            return result;
        }
        Permutation(str, result, begin);
        // 将result转换为字典序排序
        sort(result.begin(), result.end());
        return result;
    }
    void Permutation(string str, vector<string> & result, int begin){ // 注意result需要以引用方式传递
        // 递归结束条件
        if(begin == str.size()-1){
            // 判定当前字符串是否已经在result中，如果不在，则push_back到result中
            if(find(result.begin(), result.end(), str) == result.end()){
                result.push_back(str);
            }
        }
        else{
            for(int i=begin; i<str.size(); i++){     
                Swap(str[i], str[begin]);
                Permutation(str, result, begin+1);
                Swap(str[i], str[begin]);
        }
        }
    }
    void Swap(char & fir, char & sec){
        char temp = fir;
        fir = sec;
        sec = temp;
    }
};
```

## 本题扩展：不求字符的所有排列，而是求字符的所有组合。如输入三个字符a、b、c，则它们的组合有a、b、c、ab、ac、bc、abc.
### 递归解法
```c
class Solution{
public:
    vector<string> result;
    int begin = 0;
    vector<string> Combination(string str){
        if(str.empty()){
            return result;
        }
        Combination(str, result, begin);
    }
    void Combination(string str, vector<string> & result, int begin){
        // 终止条件
        if(begin == str.size()-1){
            result.push_back(str);
        }
        else{
            Combination(str, result, begin+1);
            int result_length = result.size();
            for(int i=0; i<result_length; i++){
                vector<string> temp = result;
                result.push_back(temp);
            }
        }           
    }
};
```